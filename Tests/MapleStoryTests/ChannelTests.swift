//
//  ChannelTests.swift
//  
//
//  Created by Alsey Coleman Miller on 12/22/22.
//

import Foundation

import Foundation
import XCTest
@testable import MapleStory

final class ChannelTests: XCTestCase {
    
    func testPlayerLogin() throws {
        
        let encryptedData = Data([0xF1, 0x10, 0x18, 0x4A, 0xC2, 0x3E, 0xDC, 0x17])
        let packetData = Data([0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00])
        let nonce: Nonce = 0xA4AD08D2
        
        let packet = try Packet.decrypt(
            encryptedData,
            key: .default,
            nonce: nonce,
            version: .v62
        )
        
        XCTAssertEqual(packet.data, packetData)
        
        let value = PlayerLoginRequest(client: 1)
        XCTAssertEncode(value, packet)
        XCTAssertDecode(value, packet)
    }
    
    func testServerMessageNotification() throws {
        
        /*
         MaplePacketEncoder will write encrypted 41 00 04 01 00 00
         MaplePacketEncoder header B9 BF BF BF
         MaplePacketEncoder custom encrypted 37 FB 94 7C B4 1F
         MapleAESOFB.crypt() input: 37 FB 94 7C B4 1F
         MapleAESOFB.crypt() iv: 52 30 78 40
         MapleAESOFB.crypt() output: CF 8E 16 C6 1D 79
         MaplePacketEncoder AES encrypted CF 8E 16 C6 1D 79
         MaplePacketEncoder output B9 BF BF BF CF 8E 16 C6 1D 79
         */
        
        let encryptedData = Data([0xB9, 0xBF, 0xBF, 0xBF, 0xCF, 0x8E, 0x16, 0xC6, 0x1D, 0x79])
        let packetData = Data([0x41, 0x00, 0x04, 0x01, 0x00, 0x00])
        let nonce: Nonce = 0x52307840
        
        guard let packet = Packet(data: packetData) else {
            XCTFail()
            return
        }
        
        let value = ServerMessageNotification(
            type: .topScrolling,
            isServer: true,
            message: "",
            channel: nil,
            megaEarphone: nil
        )
        
        XCTAssertEncode(value, packet)
        XCTAssertEqual(packet.opcode, 0x0041)
        
        let encrypted = try packet.encrypt(
            key: .default,
            nonce: nonce,
            version: .v62
        )
        
        XCTAssertEqual(encrypted.length, packet.data.count)
        XCTAssertEqual(encrypted.data, encryptedData)
    }
    
    func testNPCActionRequest() throws {
        
        /*
         MaplePacketDecoder encrypted packet D6 90 F0 82 73 B6 8C 57
         Recieve IV DF 53 AC 5C
         MapleAESOFB.crypt() input: D6 90 F0 82 73 B6 8C 57
         MapleAESOFB.crypt() iv: DF 53 AC 5C
         MapleAESOFB.crypt() output: FC 12 BF 5D C9 D6 0A 50
         MaplePacketDecoder AES decrypted packet FC 12 BF 5D C9 D6 0A 50
         MaplePacketDecoder custom decrypted packet A6 00 65 00 00 00 FF 00
         Incoming packet 0x00A6
         */
        
        let encryptedData = Data([0xD6, 0x90, 0xF0, 0x82, 0x73, 0xB6, 0x8C, 0x57])
        let packetData = Data([0xA6, 0x00, 0x65, 0x00, 0x00, 0x00, 0xFF, 0x00])
        let nonce: Nonce = 0xDF53AC5C
        
        let packet = try Packet.decrypt(
            encryptedData,
            key: .default,
            nonce: nonce,
            version: .v62
        )
        
        XCTAssertEqual(packet.opcode, 0x00A6)
        XCTAssertEqual(packet.data, packetData)
        
        let value = NPCActionRequest.talk(0x65, 0xFF)
        XCTAssertDecode(value, packet)
    }
    
    func testNPCActionResponse() throws {
        
        /*
         MaplePacketEncoder will write encrypted C5 00 65 00 00 00 FF 00
         MaplePacketEncoder header D5 D2 DD D2
         MaplePacketEncoder custom encrypted A3 D6 B0 86 03 DC BF CD
         MapleAESOFB.crypt() input: A3 D6 B0 86 03 DC BF CD
         MapleAESOFB.crypt() iv: E7 F7 14 2D
         MapleAESOFB.crypt() output: DA 01 35 32 4E 5C 3D D7
         MaplePacketEncoder AES encrypted DA 01 35 32 4E 5C 3D D7
         MaplePacketEncoder output D5 D2 DD D2 DA 01 35 32 4E 5C 3D D7
         */
        
        let packetData = Data([0xC5, 0x00, 0x65, 0x00, 0x00, 0x00, 0xFF, 0x00])
        let encryptedData = Data([0xD5, 0xD2, 0xDD, 0xD2, 0xDA, 0x01, 0x35, 0x32, 0x4E, 0x5C, 0x3D, 0xD7])
        let nonce: Nonce = 0xE7F7142D
        
        guard let packet = Packet(data: packetData) else {
            XCTFail()
            return
        }
        
        let value = NPCActionResponse.talk(0x65, 0xFF)
        XCTAssertEncode(value, packet)
        XCTAssertEqual(packet.opcode, 0x00C5)
        
        let encrypted = try packet.encrypt(
            key: .default,
            nonce: nonce,
            version: .v62
        )
        
        XCTAssertEqual(encrypted.length, packet.data.count)
        XCTAssertEqual(encrypted.data, encryptedData)
    }
    
    func testHealOverTimeRequest() throws {
        
        /*
         MaplePacketDecoder encrypted packet CD 64 48 B0 98 20 37 CE 0D C0 73
         Recieve IV 2E 37 48 D7
         MapleAESOFB.crypt() input: CD 64 48 B0 98 20 37 CE 0D C0 73
         MapleAESOFB.crypt() iv: 2E 37 48 D7
         MapleAESOFB.crypt() output: 1C 86 1B 96 CA 3F 71 24 C9 09 67
         MaplePacketDecoder AES decrypted packet 1C 86 1B 96 CA 3F 71 24 C9 09 67
         MaplePacketDecoder custom decrypted packet 51 00 00 14 00 00 00 00 03 00 00
         Incoming packet 0x0051
         */
        
        let encryptedData = Data([0xCD, 0x64, 0x48, 0xB0, 0x98, 0x20, 0x37, 0xCE, 0x0D, 0xC0, 0x73])
        let packetData = Data([0x51, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00])
        let nonce: Nonce = 0x2E3748D7
        
        let packet = try Packet.decrypt(
            encryptedData,
            key: .default,
            nonce: nonce,
            version: .v62
        )
        
        let value = HealOverTimeRequest(value0: 0, value1: 0x14, value2: 0, hp: 0, mp: 3, value3: 0)
        XCTAssertDecode(value, packet)
        XCTAssertEqual(packet.opcode, 0x0051)
        XCTAssertEqual(packet.data, packetData)
    }
    
    func testWarpToMap() throws {
        
        let encryptedData = Data([0x5E, 0x14, 0xBB, 0x15, 0xB3, 0xE5, 0xB3, 0xFC, 0xCA, 0x3C, 0x45, 0xEE, 0x80, 0x12, 0x09, 0x45, 0x87, 0x98, 0xE7, 0x73, 0x30, 0xAB, 0x83, 0x98, 0xB8, 0xE3, 0x86, 0xBC, 0x71, 0xE3, 0x3F, 0x92, 0x01, 0x37, 0x5E, 0x90, 0x16, 0xA8, 0x7F, 0x7D, 0xB1, 0x59, 0xF5, 0xE7, 0x16, 0xC4, 0x04, 0xAC, 0xAF, 0x8D, 0x4E, 0x62, 0x8D, 0x25, 0x19, 0xB4, 0xE0, 0x06, 0x3F, 0x8C, 0xBD, 0x8F, 0x65, 0x96, 0x08, 0xEF, 0xC6, 0x04, 0xC4, 0x18, 0x22, 0x65, 0x22, 0xF2, 0x80, 0x54, 0xE3, 0x03, 0x0C, 0x73, 0x19, 0xD6, 0xDE, 0x7D, 0x1D, 0xC5, 0x1A, 0x37, 0x55, 0x32, 0x1D, 0x7A, 0x64, 0xE2, 0x2F, 0xB5, 0x82, 0x38, 0x79, 0x96, 0x64, 0x9C, 0x87, 0xF6, 0xE9, 0x62, 0x29, 0xBA, 0x73, 0xDC, 0xE3, 0xC3, 0xC7, 0x9D, 0x19, 0xCE, 0x8A, 0xCF, 0xF0, 0x16, 0x9A, 0xB6, 0xBF, 0x31, 0x16, 0x89, 0xAB, 0xFB, 0xDC, 0x09, 0x3C, 0x09, 0xD1, 0x04, 0x45, 0x9E, 0x24, 0xD0, 0x01, 0x76, 0xB0, 0x05, 0x21, 0x92, 0x89, 0xD2, 0xD1, 0x04, 0x60, 0xA9, 0xDD, 0xA5, 0xA3, 0x0F, 0x9B, 0xB7, 0x53, 0xBE, 0x59, 0x2D, 0xF1, 0x88, 0xFA, 0x65, 0x42, 0x9B, 0x92, 0xBE, 0x67, 0x79, 0xFE, 0xA4, 0x81, 0xBA, 0xBF, 0xDD, 0x9A, 0xB6, 0x40, 0xC5, 0x01, 0x2C, 0xFE, 0x1F, 0x3B, 0xA2, 0x1E, 0x48, 0x50, 0xFD, 0xDC, 0xD4, 0x5C, 0x8A, 0xE8, 0x20, 0xBA, 0x06, 0xDF, 0x1F, 0xBA, 0xC4, 0xD3, 0x74, 0xCD, 0x44, 0x78, 0xC7, 0xF5, 0xFA, 0x9E, 0x16, 0xA2, 0x7B, 0x15, 0x5A, 0x42, 0xBD, 0x6B, 0x01, 0x5A, 0xB6, 0xD8, 0xF5, 0x94, 0x03, 0xDF, 0x76, 0x55, 0x1C, 0x64, 0xB7, 0xE4, 0x8E, 0x67, 0xB1, 0x81, 0x2F, 0x80, 0x40, 0x78, 0x06, 0x2B, 0xEF, 0xF3, 0x14, 0x98, 0xBF, 0x53, 0x06, 0xFE, 0xB2, 0x39, 0xC4, 0x4F, 0x11, 0x86, 0x3A, 0x6A, 0x81, 0x5B, 0x98, 0x3C, 0x98, 0x5E, 0x3D, 0x1A, 0x67, 0x79, 0xBA, 0xED, 0x36, 0xC7, 0xB9, 0x0C, 0xBC, 0x9B, 0x49, 0x0F, 0x06, 0x77, 0xBB, 0xC9, 0x78, 0xAC, 0x26, 0x49, 0x04, 0x09, 0x9B, 0xFE, 0xAD, 0xA9, 0xE8, 0x40, 0xEE, 0xEF, 0xCB, 0xDD, 0xC6, 0x82, 0xC3, 0xD8, 0x55, 0x2F, 0x81, 0x07, 0x6D, 0xE3, 0x50, 0x16, 0x7C, 0x92, 0xB9, 0xC9, 0xEA, 0xBB, 0xA1, 0xB4, 0x30, 0x22, 0x37, 0xEE, 0xC7, 0x19, 0x90, 0x29, 0x55, 0x47, 0xD0, 0x65, 0x62, 0xF6, 0x67, 0xE5, 0x55, 0xE5, 0x9F, 0x8A, 0x05, 0x05, 0x40, 0x59, 0xBA, 0x6D, 0x41, 0xE2, 0xE5, 0x9B, 0x56, 0xE4, 0x3E, 0x1E, 0x9C, 0x53, 0xC1, 0x98, 0xD2, 0xD9, 0x51, 0x0F, 0xC2, 0x79, 0x7C, 0x3A, 0x5D, 0x77, 0x7A, 0x23, 0x81, 0xB3, 0x36, 0xF2, 0xB0, 0x31, 0x03, 0x35, 0xD4, 0xFD, 0xAC, 0xCB, 0xC2, 0xAA, 0x95, 0xAD, 0x00, 0xDA, 0x21, 0xD4, 0xDF, 0x84, 0x9D, 0x46, 0xF1, 0x8D, 0x08, 0x31, 0x81, 0x19, 0x17, 0x19, 0xC3, 0x55, 0x05, 0x4A, 0x17, 0xAE, 0x1C, 0xC7, 0x1A, 0x1A, 0x32, 0x79, 0x56, 0xD3, 0xCB, 0xD7, 0x56, 0xA0, 0x12, 0x69, 0x87, 0x9E, 0x3E, 0x04, 0x9C, 0x52, 0xDC, 0xB8, 0xEA, 0x51, 0x94, 0xA6, 0x15, 0x62, 0x23, 0xD1, 0x94, 0x0A, 0x76, 0x6B, 0x8D, 0x67, 0x66, 0x5C, 0xAE, 0xB7, 0xE5, 0x45, 0x19, 0xC4, 0x33, 0x6E, 0x42, 0x3A, 0x79, 0x3B, 0x95, 0x9A, 0xAA, 0x82, 0x72, 0x39, 0xE4, 0x35, 0x60, 0x95, 0x94, 0xBF, 0x0E, 0x41, 0x8C, 0xBA, 0x20, 0xCE, 0xEE, 0xFD, 0x55, 0x90, 0x1A, 0x78, 0x4D, 0x97, 0x84, 0xF2, 0x32, 0x9F, 0x4A, 0x0F])
        
        let packetData = Data([0x5C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0xCB, 0x30, 0xFD, 0x8E, 0xF8, 0x17, 0xD7, 0x13, 0xCD, 0xC5, 0xAD, 0x78, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0E, 0x00, 0x00, 0x00, 0x63, 0x6F, 0x6C, 0x65, 0x6D, 0x61, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x4E, 0x00, 0x00, 0x4E, 0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x07, 0x00, 0x06, 0x00, 0x04, 0x00, 0x08, 0x00, 0x32, 0x00, 0x32, 0x00, 0x05, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x64, 0x64, 0x64, 0x64, 0x64, 0x05, 0x01, 0x82, 0xDE, 0x0F, 0x00, 0x00, 0x00, 0x80, 0x05, 0xBB, 0x46, 0xE6, 0x17, 0x02, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0xA2, 0x2C, 0x10, 0x00, 0x00, 0x00, 0x80, 0x05, 0xBB, 0x46, 0xE6, 0x17, 0x02, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x01, 0x81, 0x5B, 0x10, 0x00, 0x00, 0x00, 0x80, 0x05, 0xBB, 0x46, 0xE6, 0x17, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x01, 0xF0, 0xDD, 0x13, 0x00, 0x00, 0x00, 0x80, 0x05, 0xBB, 0x46, 0xE6, 0x17, 0x02, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0xE9, 0x7D, 0x3F, 0x00, 0x00, 0x00, 0x80, 0x05, 0xBB, 0x46, 0xE6, 0x17, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0x74, 0x10, 0x1F, 0x16, 0xD9, 0x01])
        
        let nonce: Nonce = 0xE5699FEB
        
        guard let packet = Packet(data: packetData) else {
            XCTFail()
            return
        }
        
        //let value =
        //XCTAssertEncode(value, packet)
        XCTAssertEqual(packet.opcode, 0x005C)
        
        let encrypted = try packet.encrypt(
            key: .default,
            nonce: nonce,
            version: .v62
        )
        
        XCTAssertEqual(encrypted.length, packet.data.count)
        XCTAssertEqual(encrypted.data, encryptedData)
    }
}
