//
//  ChannelTests.swift
//  
//
//  Created by Alsey Coleman Miller on 12/22/22.
//

import Foundation

import Foundation
import XCTest
@testable import MapleStory

final class ChannelTests: XCTestCase {
    
    func testPlayerLogin() throws {
        
        let encryptedData = Data([0xF1, 0x10, 0x18, 0x4A, 0xC2, 0x3E, 0xDC, 0x17])
        let packetData = Data([0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00])
        let nonce: Nonce = 0xA4AD08D2
        
        let packet = try Packet.decrypt(
            encryptedData,
            key: .default,
            nonce: nonce,
            version: .v62
        )
        
        XCTAssertEqual(packet.data, packetData)
        
        let value = PlayerLoginRequest(client: 1)
        XCTAssertEncode(value, packet)
        XCTAssertDecode(value, packet)
    }
    
    func testServerMessageNotificationTopScrolling() throws {
        
        let encryptedData = Data([0xB9, 0xBF, 0xBF, 0xBF, 0xCF, 0x8E, 0x16, 0xC6, 0x1D, 0x79])
        let packetData = Data([0x41, 0x00, 0x04, 0x01, 0x00, 0x00])
        let nonce: Nonce = 0x52307840
        
        guard let packet = Packet(data: packetData) else {
            XCTFail()
            return
        }
        
        let value = ServerMessageNotification(
            type: .topScrolling,
            isServer: true,
            message: "",
            channel: nil,
            megaEarphone: nil
        )
        
        XCTAssertEncode(value, packet)
        XCTAssertEqual(packet.opcode, 0x0041)
        
        let encrypted = try packet.encrypt(
            key: .default,
            nonce: nonce,
            version: .v62
        )
        
        XCTAssertEqual(encrypted.length, packet.data.count)
        XCTAssertEqual(encrypted.data, encryptedData)
    }
    
    func testNPCActionRequest() throws {
        
        let encryptedData = Data([0xD6, 0x90, 0xF0, 0x82, 0x73, 0xB6, 0x8C, 0x57])
        let packetData = Data([0xA6, 0x00, 0x65, 0x00, 0x00, 0x00, 0xFF, 0x00])
        let nonce: Nonce = 0xDF53AC5C
        
        let packet = try Packet.decrypt(
            encryptedData,
            key: .default,
            nonce: nonce,
            version: .v62
        )
        
        XCTAssertEqual(packet.opcode, 0x00A6)
        XCTAssertEqual(packet.data, packetData)
        
        let value = NPCActionRequest.talk(0x65, 0xFF)
        XCTAssertDecode(value, packet)
    }
    
    func testNPCActionResponse() throws {
        
        let packetData = Data([0xC5, 0x00, 0x65, 0x00, 0x00, 0x00, 0xFF, 0x00])
        let encryptedData = Data([0xD5, 0xD2, 0xDD, 0xD2, 0xDA, 0x01, 0x35, 0x32, 0x4E, 0x5C, 0x3D, 0xD7])
        let nonce: Nonce = 0xE7F7142D
        
        guard let packet = Packet(data: packetData) else {
            XCTFail()
            return
        }
        
        let value = NPCActionResponse.talk(0x65, 0xFF)
        XCTAssertEncode(value, packet)
        XCTAssertEqual(packet.opcode, 0x00C5)
        
        let encrypted = try packet.encrypt(
            key: .default,
            nonce: nonce,
            version: .v62
        )
        
        XCTAssertEqual(encrypted.length, packet.data.count)
        XCTAssertEqual(encrypted.data, encryptedData)
    }
    
    func testHealOverTimeRequest() throws {
        
        let encryptedData = Data([0xCD, 0x64, 0x48, 0xB0, 0x98, 0x20, 0x37, 0xCE, 0x0D, 0xC0, 0x73])
        let packetData = Data([0x51, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00])
        let nonce: Nonce = 0x2E3748D7
        
        let packet = try Packet.decrypt(
            encryptedData,
            key: .default,
            nonce: nonce,
            version: .v62
        )
        
        let value = HealOverTimeRequest(value0: 0, value1: 0x14, value2: 0, hp: 0, mp: 3, value3: 0)
        XCTAssertDecode(value, packet)
        XCTAssertEncode(value, packet)
        XCTAssertEqual(packet.opcode, 0x0051)
        XCTAssertEqual(packet.data, packetData)
    }
    
    func testWarpToMap() throws {
        
        let encryptedData = Data([0x5E, 0x14, 0xBB, 0x15, 0xB3, 0xE5, 0xB3, 0xFC, 0xCA, 0x3C, 0x45, 0xEE, 0x80, 0x12, 0x09, 0x45, 0x87, 0x98, 0xE7, 0x73, 0x30, 0xAB, 0x83, 0x98, 0xB8, 0xE3, 0x86, 0xBC, 0x71, 0xE3, 0x3F, 0x92, 0x01, 0x37, 0x5E, 0x90, 0x16, 0xA8, 0x7F, 0x7D, 0xB1, 0x59, 0xF5, 0xE7, 0x16, 0xC4, 0x04, 0xAC, 0xAF, 0x8D, 0x4E, 0x62, 0x8D, 0x25, 0x19, 0xB4, 0xE0, 0x06, 0x3F, 0x8C, 0xBD, 0x8F, 0x65, 0x96, 0x08, 0xEF, 0xC6, 0x04, 0xC4, 0x18, 0x22, 0x65, 0x22, 0xF2, 0x80, 0x54, 0xE3, 0x03, 0x0C, 0x73, 0x19, 0xD6, 0xDE, 0x7D, 0x1D, 0xC5, 0x1A, 0x37, 0x55, 0x32, 0x1D, 0x7A, 0x64, 0xE2, 0x2F, 0xB5, 0x82, 0x38, 0x79, 0x96, 0x64, 0x9C, 0x87, 0xF6, 0xE9, 0x62, 0x29, 0xBA, 0x73, 0xDC, 0xE3, 0xC3, 0xC7, 0x9D, 0x19, 0xCE, 0x8A, 0xCF, 0xF0, 0x16, 0x9A, 0xB6, 0xBF, 0x31, 0x16, 0x89, 0xAB, 0xFB, 0xDC, 0x09, 0x3C, 0x09, 0xD1, 0x04, 0x45, 0x9E, 0x24, 0xD0, 0x01, 0x76, 0xB0, 0x05, 0x21, 0x92, 0x89, 0xD2, 0xD1, 0x04, 0x60, 0xA9, 0xDD, 0xA5, 0xA3, 0x0F, 0x9B, 0xB7, 0x53, 0xBE, 0x59, 0x2D, 0xF1, 0x88, 0xFA, 0x65, 0x42, 0x9B, 0x92, 0xBE, 0x67, 0x79, 0xFE, 0xA4, 0x81, 0xBA, 0xBF, 0xDD, 0x9A, 0xB6, 0x40, 0xC5, 0x01, 0x2C, 0xFE, 0x1F, 0x3B, 0xA2, 0x1E, 0x48, 0x50, 0xFD, 0xDC, 0xD4, 0x5C, 0x8A, 0xE8, 0x20, 0xBA, 0x06, 0xDF, 0x1F, 0xBA, 0xC4, 0xD3, 0x74, 0xCD, 0x44, 0x78, 0xC7, 0xF5, 0xFA, 0x9E, 0x16, 0xA2, 0x7B, 0x15, 0x5A, 0x42, 0xBD, 0x6B, 0x01, 0x5A, 0xB6, 0xD8, 0xF5, 0x94, 0x03, 0xDF, 0x76, 0x55, 0x1C, 0x64, 0xB7, 0xE4, 0x8E, 0x67, 0xB1, 0x81, 0x2F, 0x80, 0x40, 0x78, 0x06, 0x2B, 0xEF, 0xF3, 0x14, 0x98, 0xBF, 0x53, 0x06, 0xFE, 0xB2, 0x39, 0xC4, 0x4F, 0x11, 0x86, 0x3A, 0x6A, 0x81, 0x5B, 0x98, 0x3C, 0x98, 0x5E, 0x3D, 0x1A, 0x67, 0x79, 0xBA, 0xED, 0x36, 0xC7, 0xB9, 0x0C, 0xBC, 0x9B, 0x49, 0x0F, 0x06, 0x77, 0xBB, 0xC9, 0x78, 0xAC, 0x26, 0x49, 0x04, 0x09, 0x9B, 0xFE, 0xAD, 0xA9, 0xE8, 0x40, 0xEE, 0xEF, 0xCB, 0xDD, 0xC6, 0x82, 0xC3, 0xD8, 0x55, 0x2F, 0x81, 0x07, 0x6D, 0xE3, 0x50, 0x16, 0x7C, 0x92, 0xB9, 0xC9, 0xEA, 0xBB, 0xA1, 0xB4, 0x30, 0x22, 0x37, 0xEE, 0xC7, 0x19, 0x90, 0x29, 0x55, 0x47, 0xD0, 0x65, 0x62, 0xF6, 0x67, 0xE5, 0x55, 0xE5, 0x9F, 0x8A, 0x05, 0x05, 0x40, 0x59, 0xBA, 0x6D, 0x41, 0xE2, 0xE5, 0x9B, 0x56, 0xE4, 0x3E, 0x1E, 0x9C, 0x53, 0xC1, 0x98, 0xD2, 0xD9, 0x51, 0x0F, 0xC2, 0x79, 0x7C, 0x3A, 0x5D, 0x77, 0x7A, 0x23, 0x81, 0xB3, 0x36, 0xF2, 0xB0, 0x31, 0x03, 0x35, 0xD4, 0xFD, 0xAC, 0xCB, 0xC2, 0xAA, 0x95, 0xAD, 0x00, 0xDA, 0x21, 0xD4, 0xDF, 0x84, 0x9D, 0x46, 0xF1, 0x8D, 0x08, 0x31, 0x81, 0x19, 0x17, 0x19, 0xC3, 0x55, 0x05, 0x4A, 0x17, 0xAE, 0x1C, 0xC7, 0x1A, 0x1A, 0x32, 0x79, 0x56, 0xD3, 0xCB, 0xD7, 0x56, 0xA0, 0x12, 0x69, 0x87, 0x9E, 0x3E, 0x04, 0x9C, 0x52, 0xDC, 0xB8, 0xEA, 0x51, 0x94, 0xA6, 0x15, 0x62, 0x23, 0xD1, 0x94, 0x0A, 0x76, 0x6B, 0x8D, 0x67, 0x66, 0x5C, 0xAE, 0xB7, 0xE5, 0x45, 0x19, 0xC4, 0x33, 0x6E, 0x42, 0x3A, 0x79, 0x3B, 0x95, 0x9A, 0xAA, 0x82, 0x72, 0x39, 0xE4, 0x35, 0x60, 0x95, 0x94, 0xBF, 0x0E, 0x41, 0x8C, 0xBA, 0x20, 0xCE, 0xEE, 0xFD, 0x55, 0x90, 0x1A, 0x78, 0x4D, 0x97, 0x84, 0xF2, 0x32, 0x9F, 0x4A, 0x0F])
        
        let packetData = Data([0x5C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0xCB, 0x30, 0xFD, 0x8E, 0xF8, 0x17, 0xD7, 0x13, 0xCD, 0xC5, 0xAD, 0x78, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0E, 0x00, 0x00, 0x00, 0x63, 0x6F, 0x6C, 0x65, 0x6D, 0x61, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x4E, 0x00, 0x00, 0x4E, 0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x07, 0x00, 0x06, 0x00, 0x04, 0x00, 0x08, 0x00, 0x32, 0x00, 0x32, 0x00, 0x05, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x64, 0x64, 0x64, 0x64, 0x64, 0x05, 0x01, 0x82, 0xDE, 0x0F, 0x00, 0x00, 0x00, 0x80, 0x05, 0xBB, 0x46, 0xE6, 0x17, 0x02, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0xA2, 0x2C, 0x10, 0x00, 0x00, 0x00, 0x80, 0x05, 0xBB, 0x46, 0xE6, 0x17, 0x02, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x01, 0x81, 0x5B, 0x10, 0x00, 0x00, 0x00, 0x80, 0x05, 0xBB, 0x46, 0xE6, 0x17, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x01, 0xF0, 0xDD, 0x13, 0x00, 0x00, 0x00, 0x80, 0x05, 0xBB, 0x46, 0xE6, 0x17, 0x02, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0xE9, 0x7D, 0x3F, 0x00, 0x00, 0x00, 0x80, 0x05, 0xBB, 0x46, 0xE6, 0x17, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0xFF, 0xC9, 0x9A, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0x74, 0x10, 0x1F, 0x16, 0xD9, 0x01])
        
        let nonce: Nonce = 0xE5699FEB
        
        guard let packet = Packet(data: packetData) else {
            XCTFail()
            return
        }
        
        //let value =
        //XCTAssertEncode(value, packet)
        XCTAssertEqual(packet.opcode, 0x005C)
        
        let encrypted = try packet.encrypt(
            key: .default,
            nonce: nonce,
            version: .v62
        )
        
        XCTAssertEqual(encrypted.length, packet.data.count)
        XCTAssertEqual(encrypted.data, encryptedData)
    }
    
    func testSpawnNPC() throws {
        
        let packetData = Data([0xC2, 0x00, 0x64, 0x00, 0x00, 0x00, 0x34, 0x08, 0x00, 0x00, 0x5B, 0xFF, 0x35, 0x00, 0x01, 0x0B, 0x00, 0x2B, 0xFF, 0x8D, 0xFF, 0x01])
        let encryptedData = Data([0xA5, 0x05, 0xB3, 0x05, 0x5D, 0x4C, 0xA6, 0x72, 0xD6, 0xBE, 0xCF, 0xD1, 0x1E, 0xDF, 0xA3, 0x9F, 0x2B, 0xC5, 0x11, 0x49, 0xDB, 0x89, 0xF0, 0xE3, 0x2E, 0x62])
        let nonce: Nonce = 0xA35464FA
        
        guard let packet = Packet(data: packetData) else {
            XCTFail()
            return
        }
        
        let value = SpawnNPCNotification(
            objectId: 100,
            id: 2100,
            x: 65371,
            cy: 53,
            f: true,
            fh: 11,
            rx0: 65323,
            rx1: 65421,
            value0: 1
        )
        XCTAssertEncode(value, packet)
        XCTAssertDecode(value, packet)
        XCTAssertEqual(packet.opcode, 0xC2)
        
        let encrypted = try packet.encrypt(
            key: .default,
            nonce: nonce,
            version: .v62
        )
        
        XCTAssertEqual(encrypted.length, packet.data.count)
        XCTAssertEqual(encrypted.data, encryptedData)
    }
    
    func testSpawnNPCRequestController() throws {
        
        let packetData = Data([0xC4, 0x00, 0x01, 0x64, 0x00, 0x00, 0x00, 0x34, 0x08, 0x00, 0x00, 0x5B, 0xFF, 0x35, 0x00, 0x01, 0x0B, 0x00, 0x2B, 0xFF, 0x8D, 0xFF, 0x01])
        let encryptedData = Data([0x65, 0xF8, 0x72, 0xF8, 0xF5, 0xAD, 0x70, 0x80, 0x27, 0xBE, 0x70, 0xA5, 0x8D, 0x09, 0x76, 0x2F, 0x9F, 0x58, 0x84, 0x07, 0x67, 0x4F, 0xAE, 0xEE, 0x95, 0x04, 0xEF])
        let nonce: Nonce = 0x0AEBA407
        
        guard let packet = Packet(data: packetData) else {
            XCTFail()
            return
        }
        
        let value = SpawnNPCRequestControllerNotification(
            value0: 1,
            objectId: 100,
            id: 2100,
            x: 65371,
            cy: 53,
            f: true,
            fh: 11,
            rx0: 65323,
            rx1: 65421,
            minimap: true
        )
        XCTAssertEncode(value, packet)
        XCTAssertDecode(value, packet)
        XCTAssertEqual(packet.opcode, 0xC4)
        
        let encrypted = try packet.encrypt(
            key: .default,
            nonce: nonce,
            version: .v62
        )
        
        XCTAssertEqual(encrypted.length, packet.data.count)
        XCTAssertEqual(encrypted.data, encryptedData)
    }
    
    func testNPCTalkRequest() throws {
        
        let encryptedData = Data([0x77, 0x90, 0x12, 0x3A, 0x9F, 0x7D, 0x90, 0xAE, 0x8C, 0xD6])
        let packetData = Data([0x36, 0x00, 0x64, 0x00, 0x00, 0x00, 0xF7, 0xFF, 0x35, 0x00])
        let nonce: Nonce = 0x7FB47235
        
        let packet = try Packet.decrypt(
            encryptedData,
            key: .default,
            nonce: nonce,
            version: .v62
        )
        
        let value = NPCTalkRequest(objectID: 0x64, value0: 0x0035FFF7)
        XCTAssertEncode(value, packet)
        XCTAssertDecode(value, packet)
        XCTAssertEqual(packet.opcode, 0x0036)
        XCTAssertEqual(packet.data, packetData)
    }
    
    func testNPCTalkNotification() throws {
        
        let encryptedData = Data([0xFD, 0x40, 0x58, 0x40, 0xAD, 0x31, 0xCA, 0x1A, 0x52, 0x65, 0x2E, 0xF8, 0x1F, 0xA9, 0x35, 0x41, 0xE7, 0x33, 0x89, 0xFF, 0x28, 0x0C, 0x2D, 0x6B, 0xD1, 0x94, 0x15, 0x2A, 0xFF, 0x5F, 0x90, 0xA6, 0xF9, 0x23, 0xC1, 0x55, 0x2E, 0xDA, 0x97, 0x92, 0xE8, 0x80, 0x21, 0x3F, 0x80, 0x86, 0xA0, 0xCF, 0x3A, 0xC2, 0x60, 0xA2, 0x02, 0x5D, 0x4C, 0xF7, 0xBE, 0xB6, 0x71, 0x2A, 0x9C, 0x72, 0xE5, 0x36, 0x93, 0x77, 0x7C, 0x49, 0x88, 0x3E, 0x0E, 0x88, 0x7E, 0x2B, 0x37, 0xEF, 0x3A, 0x45, 0xD3, 0x1A, 0xB6, 0x2D, 0xAC, 0xD6, 0x3E, 0xC3, 0x11, 0x0F, 0xCF, 0xFC, 0xC1, 0xD6, 0x4E, 0xD2, 0x0E, 0x18, 0xD4, 0xCE, 0x31, 0x5D, 0x40, 0x04, 0x92, 0x28, 0x6E, 0xDB, 0x53, 0xE2, 0x82, 0xAD, 0xFA, 0x25, 0xDE, 0x77, 0x86, 0x9D, 0xAD, 0x30, 0x72, 0x4E, 0x9C, 0x57, 0xAF, 0x5E, 0x22, 0x5E, 0xD9, 0xA9, 0xA1, 0x4E, 0xA8, 0x92, 0xC4, 0x15, 0x69, 0xE0, 0xA5, 0x18, 0x75, 0x42, 0xCF, 0xFD, 0x7B, 0x57, 0x44, 0x67, 0x8F, 0xD6, 0xDC, 0xAA, 0xD2, 0xF4, 0x34, 0x64, 0x81, 0xF9, 0x26, 0x39, 0x8A, 0x70, 0x27, 0x7D, 0xF6, 0xF1, 0x81, 0xCD, 0x0A, 0x36, 0x4F])
        
        let packetData = Data([0xED, 0x00, 0x04, 0x34, 0x08, 0x00, 0x00, 0x04, 0x9B, 0x00, 0x23, 0x62, 0x57, 0x65, 0x6C, 0x63, 0x6F, 0x6D, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x4D, 0x61, 0x70, 0x6C, 0x65, 0x53, 0x74, 0x6F, 0x72, 0x79, 0x2E, 0x20, 0x57, 0x68, 0x61, 0x74, 0x20, 0x6A, 0x6F, 0x62, 0x20, 0x64, 0x6F, 0x20, 0x79, 0x6F, 0x75, 0x20, 0x77, 0x69, 0x73, 0x68, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x65, 0x3F, 0x23, 0x6B, 0x20, 0x0D, 0x0A, 0x23, 0x4C, 0x30, 0x23, 0x42, 0x65, 0x67, 0x69, 0x6E, 0x6E, 0x65, 0x72, 0x23, 0x6C, 0x20, 0x0D, 0x0A, 0x20, 0x23, 0x4C, 0x31, 0x23, 0x57, 0x61, 0x72, 0x72, 0x69, 0x6F, 0x72, 0x23, 0x6C, 0x20, 0x0D, 0x0A, 0x20, 0x23, 0x4C, 0x32, 0x23, 0x4D, 0x61, 0x67, 0x69, 0x63, 0x69, 0x61, 0x6E, 0x23, 0x6B, 0x23, 0x6C, 0x20, 0x0D, 0x0A, 0x20, 0x23, 0x4C, 0x33, 0x23, 0x42, 0x6F, 0x77, 0x6D, 0x61, 0x6E, 0x23, 0x6C, 0x20, 0x0D, 0x0A, 0x20, 0x23, 0x4C, 0x34, 0x23, 0x54, 0x68, 0x69, 0x65, 0x66, 0x23, 0x6C, 0x20, 0x0D, 0x0A, 0x20, 0x23, 0x4C, 0x35, 0x23, 0x50, 0x69, 0x72, 0x61, 0x74, 0x65, 0x23, 0x6C])
        
        let nonce: Nonce = 0xD4EA3CBF
        
        guard let encrypedPacket = Packet.Encrypted(data: encryptedData) else {
            XCTFail()
            return
        }
        
        let packet = try encrypedPacket.decrypt(
            key: .default,
            nonce: nonce,
            version: .v62
        )
        
        let value = NPCTalkNotification.simple(
            npc: 2100,
            message: "#bWelcome to MapleStory. What job do you wish to be?#k \r\n#L0#Beginner#l \r\n #L1#Warrior#l \r\n #L2#Magician#k#l \r\n #L3#Bowman#l \r\n #L4#Thief#l \r\n #L5#Pirate#l"
        )
        XCTAssertEncode(value, packet)
        XCTAssertDecode(value, packet)
        XCTAssertEqual(packet.opcode, 0xED)
        XCTAssertEqual(packet.data, packetData)
    }
    
    func testEmptyBuddyList() throws {
        
        let packetData = Data([0x3C, 0x00, 0x07, 0x00])
        let encryptedData = Data([0x62, 0xE3, 0x66, 0xE3, 0xF0, 0x9B, 0xC2, 0x2E])
        let nonce: Nonce = 0x9D83A31C
        
        guard let encrypedPacket = Packet.Encrypted(data: encryptedData) else {
            XCTFail()
            return
        }
        
        let packet = try encrypedPacket.decrypt(
            key: .default,
            nonce: nonce,
            version: .v62
        )
        
        let value = BuddyListNotification.update([])
        
        XCTAssertEncode(value, packet)
        XCTAssertEqual(packet.opcode, 0x3C)
        XCTAssertEqual(packet.data, packetData)
    }
    
    func testShowNotesEmpty() throws {
        
        let packetData = Data([0x26, 0x00, 0x02, 0x00])
        let encryptedData = Data([0x0D, 0x1A, 0x09, 0x1A, 0x44, 0xF8, 0xA6, 0x27])
        
        let nonce: Nonce = 0xEF49CCE5
        
        guard let packet = Packet(data: packetData) else {
            XCTFail()
            return
        }
        
        let value = ShowNotesNotification(value0: 2, notes: [])
        XCTAssertEncode(value, packet)
        XCTAssertDecode(value, packet)
        XCTAssertEqual(packet.opcode, 0x0026)
        
        let encrypted = try packet.encrypt(
            key: .default,
            nonce: nonce,
            version: .v62
        )
        
        XCTAssertEqual(encrypted.length, packet.data.count)
        XCTAssertEqual(encrypted.data, encryptedData)
    }
    
    func testPlayerHint() throws {
        
        let packetData = Data([0xA9, 0x00, 0x25, 0x00, 0x59, 0x6F, 0x75, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x6D, 0x6F, 0x76, 0x65, 0x20, 0x62, 0x79, 0x20, 0x75, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x6F, 0x77, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x2E, 0xFA, 0x00, 0x05, 0x00, 0x01])
        
        let encryptedData = Data([0x91, 0x74, 0xBF, 0x74, 0xE4, 0x4E, 0x97, 0x0E, 0x79, 0x29, 0xEB, 0x8C, 0x5F, 0x80, 0xA0, 0xAB, 0xC2, 0x4C, 0xCA, 0x8E, 0x9C, 0x6D, 0x17, 0xAD, 0x96, 0xC9, 0x81, 0x2C, 0x92, 0x9C, 0x44, 0x3A, 0x38, 0x99, 0xAD, 0xB7, 0x1E, 0xAB, 0x73, 0xE5, 0x7E, 0x06, 0x94, 0xB4, 0x77, 0xD3, 0xEE, 0x93, 0x38, 0x1F])
        
        let nonce: Nonce = 0x4A07508B
        
        guard let packet = Packet(data: packetData) else {
            XCTFail()
            return
        }
        
        let value = PlayerHintNotification(hint: "You can move by using the arrow keys.", width: 250, height: 5)
        
        XCTAssertEncode(value, packet)
        XCTAssertDecode(value, packet)
        XCTAssertEqual(packet.opcode, 0x00A9)
        
        let encrypted = try packet.encrypt(
            key: .default,
            nonce: nonce,
            version: .v62
        )
        
        XCTAssertEqual(encrypted.length, packet.data.count)
        XCTAssertEqual(encrypted.data, encryptedData)
    }
    
    func testKeyMap() throws {
        
        let packetData = Data([0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x0A, 0x00, 0x00, 0x00, 0x04, 0x0C, 0x00, 0x00, 0x00, 0x04, 0x0D, 0x00, 0x00, 0x00, 0x04, 0x12, 0x00, 0x00, 0x00, 0x04, 0x18, 0x00, 0x00, 0x00, 0x04, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x08, 0x00, 0x00, 0x00, 0x04, 0x05, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x13, 0x00, 0x00, 0x00, 0x04, 0x0E, 0x00, 0x00, 0x00, 0x04, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x11, 0x00, 0x00, 0x00, 0x04, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x10, 0x00, 0x00, 0x00, 0x04, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x09, 0x00, 0x00, 0x00, 0x05, 0x32, 0x00, 0x00, 0x00, 0x05, 0x33, 0x00, 0x00, 0x00, 0x04, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x35, 0x00, 0x00, 0x00, 0x05, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x64, 0x00, 0x00, 0x00, 0x06, 0x65, 0x00, 0x00, 0x00, 0x06, 0x66, 0x00, 0x00, 0x00, 0x06, 0x67, 0x00, 0x00, 0x00, 0x06, 0x68, 0x00, 0x00, 0x00, 0x06, 0x69, 0x00, 0x00, 0x00, 0x06, 0x6A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
        
        let encryptedData = Data([0x35, 0x8A, 0xF0, 0x8B, 0x0A, 0x76, 0x19, 0x91, 0x9B, 0xCD, 0x8F, 0x16, 0x44, 0xCE, 0xA0, 0x27, 0x7C, 0x8C, 0x86, 0x9D, 0x0A, 0x86, 0x50, 0x33, 0x28, 0xC7, 0x36, 0x89, 0x5B, 0x40, 0xC8, 0x67, 0xBD, 0xE8, 0x06, 0xA8, 0x57, 0x4A, 0xDE, 0xF6, 0x85, 0xAD, 0x74, 0xEA, 0x27, 0xFD, 0x96, 0x48, 0x27, 0x72, 0xAD, 0x70, 0x3B, 0x56, 0x4C, 0x86, 0x78, 0x9B, 0x9E, 0xFB, 0xA2, 0xC0, 0xD7, 0xD9, 0x90, 0x4C, 0xCB, 0x6D, 0x03, 0x1E, 0xEB, 0xA2, 0x77, 0xCD, 0x76, 0x2C, 0xD4, 0xA6, 0x6D, 0x79, 0xDE, 0x15, 0xD7, 0x51, 0x8A, 0x74, 0x74, 0x3B, 0xAF, 0xE6, 0x76, 0x36, 0xE7, 0x66, 0x9A, 0x0D, 0x7A, 0x2A, 0xED, 0xBF, 0x79, 0xF8, 0x9F, 0xFE, 0xE6, 0xC1, 0x79, 0x85, 0x94, 0x58, 0xB6, 0x2A, 0x3D, 0x1D, 0x44, 0x80, 0x8A, 0x0B, 0xC5, 0x6A, 0xAA, 0x79, 0xE7, 0xDA, 0xCE, 0x9D, 0x84, 0x02, 0x53, 0xB9, 0x86, 0x66, 0x6B, 0x8F, 0xCE, 0xFF, 0x8F, 0x6C, 0x42, 0x81, 0xBF, 0xD6, 0x21, 0x4F, 0xC2, 0xAF, 0xBD, 0xEC, 0x80, 0xB4, 0xFB, 0x82, 0x80, 0x60, 0xCF, 0xF0, 0xC8, 0xAA, 0xC1, 0xB6, 0x1D, 0xDB, 0x17, 0x42, 0x9E, 0x69, 0x7D, 0x48, 0x7C, 0x7C, 0x61, 0x9A, 0xFC, 0x5B, 0xCC, 0xCD, 0xEC, 0xAE, 0x29, 0x0A, 0xFB, 0xEF, 0x8F, 0xB9, 0x5C, 0x1A, 0xD2, 0x53, 0x6F, 0xD3, 0x09, 0x95, 0x67, 0x9B, 0x7D, 0xD9, 0x81, 0xA0, 0x98, 0x8B, 0x28, 0xE0, 0xEF, 0x74, 0x33, 0x5F, 0x40, 0xCB, 0x8F, 0x5A, 0xB0, 0xDD, 0x4E, 0x47, 0xF1, 0xCA, 0xD2, 0xC8, 0xE9, 0x56, 0x02, 0x2C, 0x30, 0xF3, 0x1B, 0xDC, 0xE9, 0x9E, 0x41, 0xD4, 0xEF, 0x73, 0x5B, 0x32, 0x51, 0x9E, 0xF1, 0xC4, 0xD7, 0x8C, 0x9B, 0xDE, 0x6E, 0x8D, 0x38, 0xA8, 0xF4, 0xB3, 0x96, 0xDB, 0x13, 0x9D, 0xF3, 0x75, 0x19, 0xFE, 0x31, 0x44, 0x95, 0x0F, 0x74, 0xB8, 0x78, 0x3B, 0xA6, 0x43, 0xBB, 0x6D, 0xD7, 0x87, 0xF0, 0x68, 0xCE, 0x7C, 0xFE, 0x25, 0x0F, 0x82, 0x68, 0x35, 0xEB, 0x2A, 0x51, 0x8E, 0x1C, 0xE7, 0x6D, 0xAF, 0xAA, 0x16, 0x95, 0xFD, 0x6F, 0x63, 0xAE, 0x5E, 0x63, 0xA8, 0xA2, 0xBB, 0x6C, 0x29, 0x66, 0x51, 0x7A, 0x71, 0xC0, 0x45, 0x02, 0xC1, 0x2C, 0x08, 0xA7, 0xC3, 0x9F, 0x70, 0x9D, 0x87, 0xA4, 0xA6, 0xB6, 0x25, 0x68, 0x80, 0x7B, 0x2D, 0xD8, 0xF0, 0xE5, 0x42, 0xEE, 0xF5, 0xE3, 0x15, 0x08, 0xE4, 0x8A, 0x9F, 0xEC, 0x11, 0x3A, 0x8F, 0xE2, 0x1A, 0xBC, 0xC3, 0x20, 0x53, 0x7B, 0x30, 0x73, 0x78, 0xDE, 0xC7, 0x96, 0xEB, 0x64, 0xC8, 0x56, 0x81, 0x17, 0xAD, 0x1C, 0x8E, 0xE0, 0x13, 0x26, 0x8E, 0x34, 0x8E, 0xC8, 0xFF, 0x1B, 0x1B, 0xE1, 0x58, 0x40, 0x70, 0xF8, 0xFE, 0xE7, 0xF2, 0x69, 0x99, 0x9D, 0x5C, 0xC4, 0x35, 0x7F, 0x7F, 0x94, 0x20, 0x01, 0xA0, 0x25, 0x65, 0xEC, 0xDF, 0x89, 0x83, 0xA4, 0x38, 0x56, 0x94, 0xE9, 0xE4, 0x15, 0x5A, 0xBD, 0x29, 0x97, 0x36, 0xFC, 0xB7, 0x73, 0xA6, 0xC8, 0xBD, 0xBC, 0xF7, 0x2B, 0x7F, 0xB0, 0x80, 0x8B, 0xAB, 0x0C, 0x4A, 0xC1, 0xA0, 0xD2, 0x91, 0x78, 0x70, 0x5C, 0xD0, 0x96, 0x6C, 0xB7, 0x9F, 0x1F, 0xD2, 0x5F, 0x2C, 0x37, 0xC6, 0x23, 0x5D, 0xD6, 0x21, 0xF3, 0x54, 0x92, 0xD4, 0x0F, 0x4A, 0xCE])
        
        let nonce: Nonce = 0xBEA6F475
        
        guard let packet = Packet(data: packetData) else {
            XCTFail()
            return
        }
        
        let value = KeyMapNotification(keyMap: [17: MapleStory.KeyBinding(type: 4, action: 5), 35: MapleStory.KeyBinding(type: 4, action: 11), 40: MapleStory.KeyBinding(type: 4, action: 16), 5: MapleStory.KeyBinding(type: 4, action: 18), 64: MapleStory.KeyBinding(type: 6, action: 105), 19: MapleStory.KeyBinding(type: 4, action: 4), 29: MapleStory.KeyBinding(type: 5, action: 52), 34: MapleStory.KeyBinding(type: 4, action: 17), 50: MapleStory.KeyBinding(type: 4, action: 7), 61: MapleStory.KeyBinding(type: 6, action: 102), 18: MapleStory.KeyBinding(type: 4, action: 0), 57: MapleStory.KeyBinding(type: 5, action: 54), 56: MapleStory.KeyBinding(type: 5, action: 53), 60: MapleStory.KeyBinding(type: 6, action: 101), 6: MapleStory.KeyBinding(type: 4, action: 24), 25: MapleStory.KeyBinding(type: 4, action: 19), 31: MapleStory.KeyBinding(type: 4, action: 2), 45: MapleStory.KeyBinding(type: 5, action: 51), 26: MapleStory.KeyBinding(type: 4, action: 14), 3: MapleStory.KeyBinding(type: 4, action: 12), 65: MapleStory.KeyBinding(type: 6, action: 106), 7: MapleStory.KeyBinding(type: 4, action: 21), 63: MapleStory.KeyBinding(type: 6, action: 104), 27: MapleStory.KeyBinding(type: 4, action: 15), 2: MapleStory.KeyBinding(type: 4, action: 10), 62: MapleStory.KeyBinding(type: 6, action: 103), 4: MapleStory.KeyBinding(type: 4, action: 13), 23: MapleStory.KeyBinding(type: 4, action: 1), 59: MapleStory.KeyBinding(type: 6, action: 100), 16: MapleStory.KeyBinding(type: 4, action: 8), 48: MapleStory.KeyBinding(type: 4, action: 22), 41: MapleStory.KeyBinding(type: 4, action: 23), 46: MapleStory.KeyBinding(type: 4, action: 6), 43: MapleStory.KeyBinding(type: 4, action: 9), 38: MapleStory.KeyBinding(type: 4, action: 20), 44: MapleStory.KeyBinding(type: 5, action: 50), 37: MapleStory.KeyBinding(type: 4, action: 3)])
        
        XCTAssertEncode(value, packet)
        XCTAssertDecode(value, packet)
        XCTAssertEqual(packet.opcode, 0x107)
        
        let encrypted = try packet.encrypt(
            key: .default,
            nonce: nonce,
            version: .v62
        )
        
        XCTAssertEqual(encrypted.length, packet.data.count)
        XCTAssertEqual(encrypted.data, encryptedData)
    }
    
    func testPlayerUpdate() {
        
        /*
         MaplePacketDecoder encrypted packet D9 E5
         Recieve IV 0A 65 35 B0
         MapleAESOFB.crypt() input: D9 E5
         MapleAESOFB.crypt() iv: 0A 65 35 B0
         MapleAESOFB.crypt() output: 54 56
         MaplePacketDecoder AES decrypted packet 54 56
         MaplePacketDecoder custom decrypted packet C0 00
         Incoming packet 0x00C0
         */
    }
    
    func testMovePlayer() {
        
        /*
         MaplePacketDecoder encrypted packet 8C 08 25 73 B4 3D 89 76 61 15 F3 2B F6 C9 2E C3 C8 59 7F 5B 5B B2 87 77 3D F3 37 D0 67 B2 D9 D6 C4 ED DA 97 DB 07 D2 08 C5 EA 43 9D 3B DB 18 0F 31 BB 36 A3 AD 73 D8 0C 6C ED 53 A7 E1 EC E1 C9 55 6C F0 75
         Recieve IV 9A 3B C4 2B
         MapleAESOFB.crypt() input: 8C 08 25 73 B4 3D 89 76 61 15 F3 2B F6 C9 2E C3 C8 59 7F 5B 5B B2 87 77 3D F3 37 D0 67 B2 D9 D6 C4 ED DA 97 DB 07 D2 08 C5 EA 43 9D 3B DB 18 0F 31 BB 36 A3 AD 73 D8 0C 6C ED 53 A7 E1 EC E1 C9 55 6C F0 75
         MapleAESOFB.crypt() iv: 9A 3B C4 2B
         MapleAESOFB.crypt() output: 69 A4 B7 CE D3 F0 00 45 A7 77 60 13 F3 1E BD C0 31 21 57 30 25 53 D8 7F A3 D0 C3 51 81 66 99 A9 87 89 F5 38 49 E3 D2 72 89 CE 66 2A 6F 52 3E 09 42 E2 B9 96 FB E5 47 A8 6F 1C 05 81 E9 4C 5C F1 0E 58 DC B4
         MaplePacketDecoder AES decrypted packet 69 A4 B7 CE D3 F0 00 45 A7 77 60 13 F3 1E BD C0 31 21 57 30 25 53 D8 7F A3 D0 C3 51 81 66 99 A9 87 89 F5 38 49 E3 D2 72 89 CE 66 2A 6F 52 3E 09 42 E2 B9 96 FB E5 47 A8 6F 1C 05 81 E9 4C 5C F1 0E 58 DC B4
         MaplePacketDecoder custom decrypted packet 26 00 01 6C 00 1F 00 03 00 6C 00 2D 00 00 00 F0 00 00 00 06 78 00 00 6C 00 35 00 00 00 00 00 00 00 06 1A 00 00 6C 00 35 00 00 00 00 00 0B 00 04 6C 01 11 00 00 00 00 00 00 00 00 00 6C 00 1F 00 6C 00 35 00
         Incoming packet 0x0026
         */
    }
    
    func testChangeMapSpecial() {
        
        /*
         MaplePacketDecoder encrypted packet 42 69 01 92 BA E8 07 DA 91 2A 3B B9 9F 36 62 61 EC 03
         Recieve IV DA F1 55 F7
         MapleAESOFB.crypt() input: 42 69 01 92 BA E8 07 DA 91 2A 3B B9 9F 36 62 61 EC 03
         MapleAESOFB.crypt() iv: DA F1 55 F7
         MapleAESOFB.crypt() output: 91 E5 06 B8 A2 44 9B 82 D8 17 DA FE 50 96 79 CD 71 B8
         MaplePacketDecoder AES decrypted packet 91 E5 06 B8 A2 44 9B 82 D8 17 DA FE 50 96 79 CD 71 B8
         MaplePacketDecoder custom decrypted packet 5C 00 01 09 00 74 75 74 6F 72 69 61 6C 30 6C 00 35 00
         Incoming packet 0x005C
         */
        
        
    }
}
